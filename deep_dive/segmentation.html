
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Deep Dive: Using EM Segmentation Data &#8212; CRANTpy Documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'deep_dive/segmentation';</script>
    <link rel="icon" href="../_static/logo.png"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Deep Dive: From CRANTpy to Neuroglancer" href="ngllink.html" />
    <link rel="prev" title="Deep Dive: Analyzing Connectivity" href="connectivity.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>
<aside class="bd-header-announcement" aria-label="Announcement">
  <div class="bd-header-announcement__content">📚 Tutorials available! Check out the Deep Dive Gallery.</div>
</aside>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo.png" class="logo__image only-light" alt="CRANTpy Documentation - Home"/>
    <script>document.write(`<img src="../_static/logo.png" class="logo__image only-dark" alt="CRANTpy Documentation - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation &amp; Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial.html">Quickstart Tutorial</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Deep Dive</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="advanced_queries.html">Advanced Neuron Querying</a></li>
<li class="toctree-l1"><a class="reference internal" href="visualization.html">Plotting Neurons</a></li>
<li class="toctree-l1"><a class="reference internal" href="morphology.html">Working with Neuron Morphology</a></li>
<li class="toctree-l1"><a class="reference internal" href="connectivity.html">Analyzing Connectivity</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Using EM Segmentation Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="ngllink.html">From CRANTpy to Neuroglancer</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../api/modules.html">API Reference</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../api/crantpy.html">crantpy package</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../api/crantpy.queries.html">crantpy.queries package</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../api/crantpy.queries.connections.html">crantpy.queries.connections module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../api/crantpy.queries.neurons.html">crantpy.queries.neurons module</a></li>
</ul>
</details></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../api/crantpy.utils.html">crantpy.utils package</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../api/crantpy.utils.cave.html">crantpy.utils.cave package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../api/crantpy.utils.config.html">crantpy.utils.config module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../api/crantpy.utils.decorators.html">crantpy.utils.decorators module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../api/crantpy.utils.exceptions.html">crantpy.utils.exceptions module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../api/crantpy.utils.helpers.html">crantpy.utils.helpers module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../api/crantpy.utils.neuroglancer.html">crantpy.utils.neuroglancer module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../api/crantpy.utils.seatable.html">crantpy.utils.seatable module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../api/crantpy.utils.types.html">crantpy.utils.types module</a></li>
</ul>
</details></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../api/crantpy.viz.html">crantpy.viz package</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../api/crantpy.viz.l2.html">crantpy.viz.l2 module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../api/crantpy.viz.mesh.html">crantpy.viz.mesh module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../api/crantpy.viz.skeletonize.html">crantpy.viz.skeletonize module</a></li>
</ul>
</details></li>
</ul>
</details></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="../datasets.html">Datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contribute.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../acknowledgements.html">Acknowledgements</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-launch-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Launch interactive content">
    <i class="fas fa-rocket"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://mybinder.org/v2/gh/Social-Evolution-and-Behavior/crantpy/main?urlpath=lab/tree/docs/deep_dive/segmentation.ipynb" target="_blank"
   class="btn btn-sm dropdown-item"
   title="Launch on Binder"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  
    <img alt="Binder logo" src="../_static/images/logo_binder.svg">
  </span>
<span class="btn__text-container">Binder</span>
</a>
</li>
      
      
      
      
      <li><a href="https://colab.research.google.com/github/Social-Evolution-and-Behavior/crantpy/blob/main/docs/deep_dive/segmentation.ipynb" target="_blank"
   class="btn btn-sm dropdown-item"
   title="Launch on Colab"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  
    <img alt="Colab logo" src="../_static/images/logo_colab.png">
  </span>
<span class="btn__text-container">Colab</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/Social-Evolution-and-Behavior/crantpy" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/Social-Evolution-and-Behavior/crantpy/edit/main/docs/deep_dive/segmentation.ipynb" target="_blank"
   class="btn btn-sm btn-source-edit-button dropdown-item"
   title="Suggest edit"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="btn__text-container">Suggest edit</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/Social-Evolution-and-Behavior/crantpy/issues/new?title=Issue%20on%20page%20%2Fdeep_dive/segmentation.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/deep_dive/segmentation.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Deep Dive: Using EM Segmentation Data</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#authentication-setup">1. Authentication Setup</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#root-ids-and-supervoxels">2. Root IDs and Supervoxels</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#converting-root-ids-to-supervoxels">Converting Root IDs to Supervoxels</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#converting-supervoxels-to-root-ids">Converting Supervoxels to Root IDs</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#location-based-segmentation-queries">3. Location-Based Segmentation Queries</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#finding-supervoxels-at-locations">Finding Supervoxels at Locations</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#finding-root-ids-segments-at-locations">Finding Root IDs (Segments) at Locations</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#updating-and-validating-root-ids">4. Updating and Validating Root IDs</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#validating-root-ids">Validating Root IDs</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#updating-outdated-root-ids">Updating Outdated Root IDs</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#mapping-neurons-to-segmentation">5. Mapping Neurons to Segmentation</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#finding-overlapping-segments">Finding Overlapping Segments</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#segmentation-cutouts">6. Segmentation Cutouts</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#extracting-a-volume-of-segmentation">Extracting a Volume of Segmentation</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#voxel-level-operations">7. Voxel-Level Operations</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#getting-all-voxels-for-a-neuron">Getting All Voxels for a Neuron</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#spatial-coordinate-correction">8. Spatial Coordinate Correction</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#snapping-coordinates-to-segmentation">Snapping Coordinates to Segmentation</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#temporal-analysis-edit-history">9. Temporal Analysis: Edit History</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#getting-the-lineage-graph">Getting the Lineage Graph</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#finding-common-time-points">Finding Common Time Points</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#practical-workflows">10. Practical Workflows</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#workflow-1-validating-and-updating-a-list-of-neurons">Workflow 1: Validating and Updating a List of Neurons</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#workflow-2-quality-control-for-synapse-annotations">Workflow 2: Quality Control for Synapse Annotations</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#workflow-3-analyzing-segmentation-in-a-region">Workflow 3: Analyzing Segmentation in a Region</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#performance-tips-and-best-practices">11. Performance Tips and Best Practices</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tip-1-cache-supervoxels-for-faster-updates">Tip 1: Cache Supervoxels for Faster Updates</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tip-2-use-appropriate-mip-levels">Tip 2: Use Appropriate MIP Levels</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tip-3-batch-operations">Tip 3: Batch Operations</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#summary">Summary</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#key-takeaways">Key Takeaways</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#common-use-cases">Common Use Cases</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#important-notes-on-voxel-operations">Important Notes on Voxel Operations</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="deep-dive-using-em-segmentation-data">
<h1>Deep Dive: Using EM Segmentation Data<a class="headerlink" href="#deep-dive-using-em-segmentation-data" title="Link to this heading">#</a></h1>
<p>This comprehensive tutorial explores the powerful segmentation capabilities of CRANTpy using CAVE. We’ll cover:</p>
<ul class="simple">
<li><p><strong>Root and supervoxel conversions</strong> - Working with different segmentation levels</p></li>
<li><p><strong>Location-based queries</strong> - Finding segmentation at specific coordinates</p></li>
<li><p><strong>ID updates and validation</strong> - Keeping root IDs current</p></li>
<li><p><strong>Neuron mapping</strong> - Connecting spatial data to segmentation</p></li>
<li><p><strong>Voxel operations</strong> - Working with voxel-level data</p></li>
<li><p><strong>Temporal analysis</strong> - Understanding segmentation history</p></li>
<li><p><strong>Spatial corrections</strong> - Snapping coordinates to segmentation</p></li>
</ul>
<p>These tools are essential for working with dynamic segmentation data in CAVE/ChunkedGraph systems.</p>
<p>Let’s get started by setting up our environment.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import CRANTpy and other necessary libraries</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">crantpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">seaborn</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sns</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">navis</span>

<span class="c1"># Set up logging to see progress</span>
<span class="n">cp</span><span class="o">.</span><span class="n">set_logging_level</span><span class="p">(</span><span class="s2">&quot;WARNING&quot;</span><span class="p">)</span>  <span class="c1"># Quieter for this tutorial</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;CRANTpy loaded successfully!&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Default dataset: </span><span class="si">{</span><span class="n">cp</span><span class="o">.</span><span class="n">CRANT_DEFAULT_DATASET</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>CRANTpy loaded successfully!
Default dataset: latest
</pre></div>
</div>
</div>
</div>
<section id="authentication-setup">
<h2>1. Authentication Setup<a class="headerlink" href="#authentication-setup" title="Link to this heading">#</a></h2>
<p>Before we can access the data, we need to authenticate with the CAVE service. This is typically a one-time setup.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Generate and save authentication token (uncomment if first time)</span>
<span class="c1"># cp.generate_cave_token(save=True)</span>

<span class="c1"># Test connection</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">client</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">get_cave_client</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Successfully connected to datastack: </span><span class="si">{</span><span class="n">client</span><span class="o">.</span><span class="n">datastack_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Server: </span><span class="si">{</span><span class="n">client</span><span class="o">.</span><span class="n">server_address</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Connection failed: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Please run: cp.generate_cave_token(save=True)&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Successfully connected to datastack: kronauer_ant
Server: https://proofreading.zetta.ai
</pre></div>
</div>
</div>
</div>
</section>
<section id="root-ids-and-supervoxels">
<h2>2. Root IDs and Supervoxels<a class="headerlink" href="#root-ids-and-supervoxels" title="Link to this heading">#</a></h2>
<p>CAVE segmentation has a hierarchical structure:</p>
<ul class="simple">
<li><p><strong>Supervoxels</strong> - The smallest atomic units (never change)</p></li>
<li><p><strong>L2 chunks</strong> - Groups of supervoxels</p></li>
<li><p><strong>Root IDs</strong> - The top-level segments that represent neurons (can change with edits)</p></li>
</ul>
<p>Understanding this hierarchy is crucial for working with dynamic segmentation.</p>
<section id="converting-root-ids-to-supervoxels">
<h3>Converting Root IDs to Supervoxels<a class="headerlink" href="#converting-root-ids-to-supervoxels" title="Link to this heading">#</a></h3>
<p>Supervoxels are stable - they never change even when neurons are edited. This makes them useful for tracking neurons over time.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get some example neurons</span>
<span class="n">example_neurons</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">NeuronCriteria</span><span class="p">(</span><span class="n">cell_class</span><span class="o">=</span><span class="s1">&#39;olfactory_projection_neuron&#39;</span><span class="p">,</span> <span class="n">proofread</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">example_ids</span> <span class="o">=</span> <span class="n">example_neurons</span><span class="o">.</span><span class="n">get_roots</span><span class="p">()[:</span><span class="mi">3</span><span class="p">]</span>  <span class="c1"># Get first 3</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Example root IDs: </span><span class="si">{</span><span class="n">example_ids</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Convert to supervoxels</span>
<span class="n">sv_dict</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">roots_to_supervoxels</span><span class="p">(</span><span class="n">example_ids</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Supervoxel breakdown:&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">root_id</span><span class="p">,</span> <span class="n">supervoxels</span> <span class="ow">in</span> <span class="n">sv_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Root </span><span class="si">{</span><span class="n">root_id</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">supervoxels</span><span class="p">)</span><span class="si">:</span><span class="s2">,</span><span class="si">}</span><span class="s2"> supervoxels&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    First 5: </span><span class="si">{</span><span class="n">supervoxels</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Example root IDs: [&#39;576460752681552812&#39; &#39;576460752773799604&#39; &#39;576460752656800770&#39;]
</pre></div>
</div>
<script type="application/vnd.jupyter.widget-view+json">{"model_id": "5faa74f7a1144999ab60590ced6ff72a", "version_major": 2, "version_minor": 0}</script><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Supervoxel breakdown:
  Root 576460752656800770: 155,486 supervoxels
    First 5: [74873375269027774 74873375268949798 74873375268996643 74873375268993836
 74873375268949820]

  Root 576460752681552812: 100,119 supervoxels
    First 5: [74310013535161003 74310013535166331 74310013535158359 74310013535158357
 74310013535158351]

  Root 576460752773799604: 115,050 supervoxels
    First 5: [74239507016850136 74239507016847407 74239507016839180 74239507016836277
 74239507016836287]
</pre></div>
</div>
</div>
</div>
</section>
<section id="converting-supervoxels-to-root-ids">
<h3>Converting Supervoxels to Root IDs<a class="headerlink" href="#converting-supervoxels-to-root-ids" title="Link to this heading">#</a></h3>
<p>You can also go the other direction - from supervoxels to root IDs. This is useful for finding which neuron a supervoxel belongs to.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Starting root ID: </span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">example_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Take some supervoxels from our first neuron</span>
<span class="n">sample_supervoxels</span> <span class="o">=</span> <span class="n">sv_dict</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">example_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">])][:</span><span class="mi">10</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Sample supervoxels: </span><span class="si">{</span><span class="n">sample_supervoxels</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Convert back to root IDs</span>
<span class="n">roots_from_sv</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">supervoxels_to_roots</span><span class="p">(</span><span class="n">sample_supervoxels</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Root IDs from supervoxels: </span><span class="si">{</span><span class="n">roots_from_sv</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;All belong to same root? </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">roots_from_sv</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">int</span><span class="p">(</span><span class="n">example_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># You can also query at a specific time</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- Time-based queries ---&quot;</span><span class="p">)</span>
<span class="n">roots_current</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">supervoxels_to_roots</span><span class="p">(</span><span class="n">sample_supervoxels</span><span class="p">,</span> <span class="n">timestamp</span><span class="o">=</span><span class="s2">&quot;mat&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Current root IDs: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">roots_current</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Starting root ID: 576460752681552812

Sample supervoxels: [74310013535161003 74310013535166331 74310013535158359 74310013535158357
 74310013535158351 74310013535155583 74239575668933333 74239575668922938
 74239575668839596 74239575668689743]

Root IDs from supervoxels: [576460752681552812 576460752681552812 576460752681552812
 576460752681552812 576460752681552812 576460752681552812
 576460752681552812 576460752681552812 576460752681552812
 576460752681552812]
All belong to same root? True

--- Time-based queries ---
Current root IDs: [576460752681552812]
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="location-based-segmentation-queries">
<h2>3. Location-Based Segmentation Queries<a class="headerlink" href="#location-based-segmentation-queries" title="Link to this heading">#</a></h2>
<p>One of the most useful operations is finding which segment exists at a specific x/y/z location.</p>
<section id="finding-supervoxels-at-locations">
<h3>Finding Supervoxels at Locations<a class="headerlink" href="#finding-supervoxels-at-locations" title="Link to this heading">#</a></h3>
<p>Get the supervoxel ID at specific coordinates.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># first lets get the location of a random l2 node from each of our example neurons</span>
<span class="n">locations</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">example_ids</span><span class="p">)):</span>
    <span class="n">skel</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">get_l2_skeleton</span><span class="p">(</span><span class="n">example_ids</span><span class="p">)</span>
    <span class="c1"># pick a random index from the node list</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">skel</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
    <span class="c1"># get the location of the l2 node and</span>
    <span class="n">locations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">skel</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">,[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
<span class="n">locations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">locations</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<script type="application/vnd.jupyter.widget-view+json">{"model_id": "1842cc748aed4725acb3bfa954fe19af", "version_major": 2, "version_minor": 0}</script><script type="application/vnd.jupyter.widget-view+json">{"model_id": "c0e97b633ae54854b762462b7aa0f0ca", "version_major": 2, "version_minor": 0}</script><script type="application/vnd.jupyter.widget-view+json">{"model_id": "65b96030b8d9434788b4111e69eda8c1", "version_major": 2, "version_minor": 0}</script></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Querying </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">locations</span><span class="p">)</span><span class="si">}</span><span class="s2"> locations...&quot;</span><span class="p">)</span>

<span class="c1"># Get supervoxel IDs at these locations</span>
<span class="n">supervoxels_at_locs</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">locs_to_supervoxels</span><span class="p">(</span>
    <span class="n">locations</span><span class="p">,</span> 
    <span class="n">coordinates</span><span class="o">=</span><span class="s2">&quot;nm&quot;</span><span class="p">,</span>
    <span class="n">mip</span><span class="o">=</span><span class="mi">0</span>  <span class="c1"># Highest resolution</span>
<span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Supervoxel IDs at locations:&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">sv_id</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">locations</span><span class="p">,</span> <span class="n">supervoxels_at_locs</span><span class="p">)):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Location </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">: supervoxel </span><span class="si">{</span><span class="n">sv_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># You can also use DataFrames</span>
<span class="n">loc_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">locations</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">])</span>
<span class="n">supervoxels_df</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">locs_to_supervoxels</span><span class="p">(</span><span class="n">loc_df</span><span class="p">,</span> <span class="n">coordinates</span><span class="o">=</span><span class="s2">&quot;nm&quot;</span><span class="p">)</span>
<span class="n">loc_df</span><span class="p">[</span><span class="s1">&#39;supervoxel_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">supervoxels_df</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Locations DataFrame:&quot;</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">loc_df</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Querying 3 locations...
</pre></div>
</div>
<script type="application/vnd.jupyter.widget-view+json">{"model_id": "a71f512e6089430293ba7fe7937154bd", "version_major": 2, "version_minor": 0}</script><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Supervoxel IDs at locations:
  Location 1 [np.float64(331200.0) np.float64(93376.0) np.float64(112812.0)]: supervoxel 74732225463459004
  Location 2 [np.float64(305488.0) np.float64(107744.0) np.float64(186312.0)]: supervoxel 74521257139550053
  Location 3 [np.float64(254752.0) np.float64(236672.0) np.float64(75222.0)]: supervoxel 74100074728972648
</pre></div>
</div>
<script type="application/vnd.jupyter.widget-view+json">{"model_id": "b70cf1d703f447a8aa40c7f2ec2b7f96", "version_major": 2, "version_minor": 0}</script><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Locations DataFrame:
</pre></div>
</div>
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>x</th>
      <th>y</th>
      <th>z</th>
      <th>supervoxel_id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>331200.0</td>
      <td>93376.0</td>
      <td>112812.0</td>
      <td>74732225463459004</td>
    </tr>
    <tr>
      <th>1</th>
      <td>305488.0</td>
      <td>107744.0</td>
      <td>186312.0</td>
      <td>74521257139550053</td>
    </tr>
    <tr>
      <th>2</th>
      <td>254752.0</td>
      <td>236672.0</td>
      <td>75222.0</td>
      <td>74100074728972648</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
</section>
<section id="finding-root-ids-segments-at-locations">
<h3>Finding Root IDs (Segments) at Locations<a class="headerlink" href="#finding-root-ids-segments-at-locations" title="Link to this heading">#</a></h3>
<p>More commonly, you want to know which neuron (root ID) is at a location.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get root IDs at the same locations</span>
<span class="n">root_ids_at_locs</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">locs_to_segments</span><span class="p">(</span>
    <span class="n">locations</span><span class="p">,</span>
    <span class="n">coordinates</span><span class="o">=</span><span class="s2">&quot;nm&quot;</span><span class="p">,</span>
    <span class="n">timestamp</span><span class="o">=</span><span class="s2">&quot;mat&quot;</span>  <span class="c1"># Use latest materialization</span>
<span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Root IDs at locations:&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">root_id</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">locations</span><span class="p">,</span> <span class="n">root_ids_at_locs</span><span class="p">)):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Location </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">: root ID </span><span class="si">{</span><span class="n">root_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Check if any locations hit the same neuron</span>
<span class="n">unique_roots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">root_ids_at_locs</span><span class="p">[</span><span class="n">root_ids_at_locs</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_roots</span><span class="p">)</span><span class="si">}</span><span class="s2"> unique neurons at these locations&quot;</span><span class="p">)</span>

<span class="c1"># Get annotations for these neurons</span>
<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_roots</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">annotations</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">get_annotations</span><span class="p">(</span><span class="n">unique_roots</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Neurons found at locations:&quot;</span><span class="p">)</span>
    <span class="n">display</span><span class="p">(</span><span class="n">annotations</span><span class="p">[[</span><span class="s1">&#39;root_id&#39;</span><span class="p">,</span> <span class="s1">&#39;cell_class&#39;</span><span class="p">,</span> <span class="s1">&#39;cell_type&#39;</span><span class="p">,</span> <span class="s1">&#39;side&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="n">unique_roots</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<script type="application/vnd.jupyter.widget-view+json">{"model_id": "b0acf74ca7d744a082cf2b4503704eb8", "version_major": 2, "version_minor": 0}</script><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Root IDs at locations:
  Location 1 [np.float64(331200.0) np.float64(93376.0) np.float64(112812.0)]: root ID 576460752681552812
  Location 2 [np.float64(305488.0) np.float64(107744.0) np.float64(186312.0)]: root ID 576460752656800770
  Location 3 [np.float64(254752.0) np.float64(236672.0) np.float64(75222.0)]: root ID 576460752681552812

Found 2 unique neurons at these locations

Neurons found at locations:
</pre></div>
</div>
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>root_id</th>
      <th>cell_class</th>
      <th>cell_type</th>
      <th>side</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>576460752681552812</td>
      <td>olfactory_projection_neuron</td>
      <td>None</td>
      <td>left</td>
    </tr>
    <tr>
      <th>5</th>
      <td>576460752656800770</td>
      <td>olfactory_projection_neuron</td>
      <td>None</td>
      <td>right</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
</section>
</section>
<section id="updating-and-validating-root-ids">
<h2>4. Updating and Validating Root IDs<a class="headerlink" href="#updating-and-validating-root-ids" title="Link to this heading">#</a></h2>
<p>Root IDs can become outdated as neurons are edited (merged/split). CRANTpy provides tools to check and update IDs.</p>
<section id="validating-root-ids">
<h3>Validating Root IDs<a class="headerlink" href="#validating-root-ids" title="Link to this heading">#</a></h3>
<p>Check if root IDs are valid and current.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Check if root IDs are valid</span>
<span class="n">test_ids</span> <span class="o">=</span> <span class="n">example_ids</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Testing </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">test_ids</span><span class="p">)</span><span class="si">}</span><span class="s2"> root IDs...&quot;</span><span class="p">)</span>

<span class="c1"># Check validity</span>
<span class="n">is_valid</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">is_valid_root</span><span class="p">(</span><span class="n">test_ids</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Validity check:&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">root_id</span><span class="p">,</span> <span class="n">valid</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">test_ids</span><span class="p">,</span> <span class="n">is_valid</span><span class="p">):</span>
    <span class="n">status</span> <span class="o">=</span> <span class="s2">&quot;✓ Valid&quot;</span> <span class="k">if</span> <span class="n">valid</span> <span class="k">else</span> <span class="s2">&quot;✗ Invalid&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">root_id</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">status</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Check if they&#39;re the latest version</span>
<span class="n">is_latest</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">is_latest_roots</span><span class="p">(</span><span class="n">test_ids</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Latest check:&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">root_id</span><span class="p">,</span> <span class="n">latest</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">test_ids</span><span class="p">,</span> <span class="n">is_latest</span><span class="p">):</span>
    <span class="n">status</span> <span class="o">=</span> <span class="s2">&quot;✓ Current&quot;</span> <span class="k">if</span> <span class="n">latest</span> <span class="k">else</span> <span class="s2">&quot;✗ Outdated&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">root_id</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">status</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Summary</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Summary: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">is_valid</span><span class="p">)</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">test_ids</span><span class="p">)</span><span class="si">}</span><span class="s2"> valid, </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">is_latest</span><span class="p">)</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">test_ids</span><span class="p">)</span><span class="si">}</span><span class="s2"> current&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Testing 3 root IDs...

Validity check:
  576460752681552812: ✓ Valid
  576460752773799604: ✓ Valid
  576460752656800770: ✓ Valid

Latest check:
  576460752681552812: ✓ Current
  576460752773799604: ✓ Current
  576460752656800770: ✓ Current

Summary: 3/3 valid, 3/3 current
</pre></div>
</div>
</div>
</div>
</section>
<section id="updating-outdated-root-ids">
<h3>Updating Outdated Root IDs<a class="headerlink" href="#updating-outdated-root-ids" title="Link to this heading">#</a></h3>
<p>If you have outdated root IDs, you can update them to the current version.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Update root IDs to latest version</span>
<span class="n">update_result</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">update_ids</span><span class="p">(</span><span class="n">test_ids</span><span class="p">,</span> <span class="n">progress</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Update results:&quot;</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">update_result</span><span class="p">)</span>

<span class="c1"># Check which IDs changed</span>
<span class="n">changed</span> <span class="o">=</span> <span class="n">update_result</span><span class="p">[</span><span class="n">update_result</span><span class="p">[</span><span class="s1">&#39;changed&#39;</span><span class="p">]]</span>
<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">changed</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">changed</span><span class="p">)</span><span class="si">}</span><span class="s2"> IDs were updated:&quot;</span><span class="p">)</span>
    <span class="n">display</span><span class="p">(</span><span class="n">changed</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">✓ All IDs were already current!&quot;</span><span class="p">)</span>

<span class="c1"># Update with supervoxels (much faster if you have them)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- Using supervoxels for faster updates ---&quot;</span><span class="p">)</span>
<span class="c1"># If you have supervoxels saved from earlier</span>
<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sv_dict</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="c1"># Get the first root from sv_dict</span>
    <span class="n">first_root</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sv_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># Get first supervoxel and ensure it&#39;s a Python int</span>
    <span class="c1"># sv_dict[root_id] returns an array of supervoxels</span>
    <span class="n">first_sv_array</span> <span class="o">=</span> <span class="n">sv_dict</span><span class="p">[</span><span class="n">first_root</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">first_sv_array</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">first_sv</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">first_sv_array</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Testing with root ID: </span><span class="si">{</span><span class="n">first_root</span><span class="si">}</span><span class="s2">, supervoxel: </span><span class="si">{</span><span class="n">first_sv</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="n">update_with_sv</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">update_ids</span><span class="p">(</span>
                <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">first_root</span><span class="p">)],</span>  <span class="c1"># Ensure root is also int</span>
                <span class="n">supervoxels</span><span class="o">=</span><span class="p">[</span><span class="n">first_sv</span><span class="p">],</span>
                <span class="n">progress</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Update with supervoxel:&quot;</span><span class="p">)</span>
            <span class="n">display</span><span class="p">(</span><span class="n">update_with_sv</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Error during update with supervoxel: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No supervoxels found for first root&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No supervoxels available in sv_dict&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2025-10-04 16:11:23 - WARNING - Multiple supervoxel IDs found for 130 root IDs. Using first occurrence for each.
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Update results:
</pre></div>
</div>
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>old_id</th>
      <th>new_id</th>
      <th>confidence</th>
      <th>changed</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>576460752681552812</td>
      <td>576460752681552812</td>
      <td>1.0</td>
      <td>False</td>
    </tr>
    <tr>
      <th>1</th>
      <td>576460752773799604</td>
      <td>576460752773799604</td>
      <td>1.0</td>
      <td>False</td>
    </tr>
    <tr>
      <th>2</th>
      <td>576460752656800770</td>
      <td>576460752656800770</td>
      <td>1.0</td>
      <td>False</td>
    </tr>
  </tbody>
</table>
</div></div><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>✓ All IDs were already current!

--- Using supervoxels for faster updates ---
Testing with root ID: 576460752656800770, supervoxel: 74873375269027774

Update with supervoxel:
</pre></div>
</div>
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>old_id</th>
      <th>new_id</th>
      <th>confidence</th>
      <th>changed</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>576460752656800770</td>
      <td>576460752656800770</td>
      <td>1.0</td>
      <td>False</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
</section>
</section>
<section id="mapping-neurons-to-segmentation">
<h2>5. Mapping Neurons to Segmentation<a class="headerlink" href="#mapping-neurons-to-segmentation" title="Link to this heading">#</a></h2>
<p>If you have neuron reconstructions (skeletons), you can find which root IDs they overlap with.</p>
<section id="finding-overlapping-segments">
<h3>Finding Overlapping Segments<a class="headerlink" href="#finding-overlapping-segments" title="Link to this heading">#</a></h3>
<p>This is useful for:</p>
<ul class="simple">
<li><p>Validating that a skeleton matches the expected segmentation</p></li>
<li><p>Finding which segments a tracing overlaps with</p></li>
<li><p>Quality control of reconstructions</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># For this example, we&#39;ll create a simple synthetic neuron</span>
<span class="c1"># In practice, you would load your actual neuron data</span>

<span class="n">center_location</span> <span class="o">=</span> <span class="n">locations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Use the first location from earlier</span>
<span class="n">spread</span> <span class="o">=</span> <span class="mi">2000</span>  <span class="c1"># Spread of the synthetic neuron</span>

<span class="c1"># Create a simple TreeNeuron with nodes in your space</span>
<span class="n">nodes_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
    <span class="s1">&#39;node_id&#39;</span><span class="p">:</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span>
    <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">center_location</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">spread</span><span class="p">,</span> <span class="n">center_location</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">spread</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span>
    <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">center_location</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">spread</span><span class="p">,</span> <span class="n">center_location</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">spread</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span>
    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">center_location</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">spread</span><span class="p">,</span> <span class="n">center_location</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">spread</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span>
    <span class="s1">&#39;parent_id&#39;</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">19</span><span class="p">))</span>
<span class="p">})</span>

<span class="n">test_neuron</span> <span class="o">=</span> <span class="n">navis</span><span class="o">.</span><span class="n">TreeNeuron</span><span class="p">(</span><span class="n">nodes_data</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;nm&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Created test neuron with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">test_neuron</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span><span class="si">}</span><span class="s2"> nodes&quot;</span><span class="p">)</span>

<span class="c1"># Find which segments overlap with this neuron</span>
<span class="n">overlap_summary</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">neuron_to_segments</span><span class="p">(</span>
    <span class="n">test_neuron</span><span class="p">,</span>
    <span class="n">short</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>  <span class="c1"># Just get top match</span>
    <span class="n">coordinates</span><span class="o">=</span><span class="s2">&quot;nm&quot;</span>
<span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Best matching segment:&quot;</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">overlap_summary</span><span class="p">)</span>

<span class="c1"># Get full overlap matrix</span>
<span class="n">overlap_matrix</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">neuron_to_segments</span><span class="p">(</span>
    <span class="n">test_neuron</span><span class="p">,</span>
    <span class="n">short</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">coordinates</span><span class="o">=</span><span class="s2">&quot;nm&quot;</span>
<span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Full overlap matrix:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Shape: </span><span class="si">{</span><span class="n">overlap_matrix</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">overlap_matrix</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Created test neuron with 20 nodes
</pre></div>
</div>
<script type="application/vnd.jupyter.widget-view+json">{"model_id": "c28ddf457ffa4736be7ad7cd8d80a3d6", "version_major": 2, "version_minor": 0}</script><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Best matching segment:
</pre></div>
</div>
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id</th>
      <th>match</th>
      <th>confidence</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>6a033bea-6948-4e10-9229-431c8f5e7a22</td>
      <td>576460752681552812</td>
      <td>0.1</td>
    </tr>
  </tbody>
</table>
</div></div><script type="application/vnd.jupyter.widget-view+json">{"model_id": "ebe985f4e68241f7be12dbedad18ad06", "version_major": 2, "version_minor": 0}</script><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Full overlap matrix:
Shape: (13, 1)
</pre></div>
</div>
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>id</th>
      <th>6a033bea-6948-4e10-9229-431c8f5e7a22</th>
    </tr>
    <tr>
      <th>root_id</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>576460752502203165</th>
      <td>1</td>
    </tr>
    <tr>
      <th>576460752502255389</th>
      <td>1</td>
    </tr>
    <tr>
      <th>576460752551876313</th>
      <td>1</td>
    </tr>
    <tr>
      <th>576460752552099545</th>
      <td>1</td>
    </tr>
    <tr>
      <th>576460752552427737</th>
      <td>1</td>
    </tr>
    <tr>
      <th>576460752642804358</th>
      <td>1</td>
    </tr>
    <tr>
      <th>576460752679586871</th>
      <td>3</td>
    </tr>
    <tr>
      <th>576460752681552812</th>
      <td>5</td>
    </tr>
    <tr>
      <th>576460752693418619</th>
      <td>2</td>
    </tr>
    <tr>
      <th>576460752699284028</th>
      <td>1</td>
    </tr>
    <tr>
      <th>576460752717903902</th>
      <td>1</td>
    </tr>
    <tr>
      <th>576460752743326756</th>
      <td>1</td>
    </tr>
    <tr>
      <th>576460752759576234</th>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
</section>
</section>
<section id="segmentation-cutouts">
<h2>6. Segmentation Cutouts<a class="headerlink" href="#segmentation-cutouts" title="Link to this heading">#</a></h2>
<p>You can extract a 3D volume of segmentation data in a bounding box.</p>
<section id="extracting-a-volume-of-segmentation">
<h3>Extracting a Volume of Segmentation<a class="headerlink" href="#extracting-a-volume-of-segmentation" title="Link to this heading">#</a></h3>
<p>This is useful for:</p>
<ul class="simple">
<li><p>Analyzing local connectivity</p></li>
<li><p>Visualizing segmentation in 3D</p></li>
<li><p>Finding all segments in a region</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define a small bounding box (in nanometers)</span>
<span class="c1"># Format: [[xmin, xmax], [ymin, ymax], [zmin, zmax]]</span>

<span class="c1"># create a box around the center_location</span>
<span class="n">bbox</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="n">center_location</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2000</span><span class="p">,</span> <span class="n">center_location</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2000</span><span class="p">],</span>
    <span class="p">[</span><span class="n">center_location</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2000</span><span class="p">,</span> <span class="n">center_location</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2000</span><span class="p">],</span>
    <span class="p">[</span><span class="n">center_location</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">100</span><span class="p">,</span> <span class="n">center_location</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">100</span><span class="p">]</span>
<span class="p">])</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fetching segmentation cutout...&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Bounding box (nm):&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  X: </span><span class="si">{</span><span class="n">bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Y: </span><span class="si">{</span><span class="n">bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Z: </span><span class="si">{</span><span class="n">bbox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Get the cutout with root IDs</span>
<span class="n">cutout</span><span class="p">,</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">get_segmentation_cutout</span><span class="p">(</span>
    <span class="n">bbox</span><span class="p">,</span>
    <span class="n">root_ids</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>  <span class="c1"># Get root IDs (not supervoxels)</span>
    <span class="n">mip</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>          <span class="c1"># Lower resolution for faster fetching</span>
    <span class="n">coordinates</span><span class="o">=</span><span class="s2">&quot;nm&quot;</span>
<span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Cutout info:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Shape: </span><span class="si">{</span><span class="n">cutout</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Resolution: </span><span class="si">{</span><span class="n">resolution</span><span class="si">}</span><span class="s2"> nm/voxel&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Offset: </span><span class="si">{</span><span class="n">offset</span><span class="si">}</span><span class="s2"> nm&quot;</span><span class="p">)</span>

<span class="c1"># Find unique segments in this volume</span>
<span class="n">unique_segments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cutout</span><span class="p">)</span>
<span class="n">unique_segments</span> <span class="o">=</span> <span class="n">unique_segments</span><span class="p">[</span><span class="n">unique_segments</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># Remove background</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_segments</span><span class="p">)</span><span class="si">}</span><span class="s2"> unique segments in this volume&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Segment IDs: </span><span class="si">{</span><span class="n">unique_segments</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>  <span class="c1"># Show first 10</span>

<span class="c1"># map the values to a contiguous range for better visualization</span>
<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_segments</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">segment_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">seg_id</span><span class="p">:</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">seg_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_segments</span><span class="p">)}</span>
    <span class="n">vectorized_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">segment_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">cutout</span> <span class="o">=</span> <span class="n">vectorized_map</span><span class="p">(</span><span class="n">cutout</span><span class="p">)</span>

<span class="c1"># Visualize a slice</span>
<span class="k">if</span> <span class="n">cutout</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">mid_z</span> <span class="o">=</span> <span class="n">cutout</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cutout</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">mid_z</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;tab20&#39;</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Segmentation Cutout (Z-slice </span><span class="si">{</span><span class="n">mid_z</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">fontweight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;X (voxels)&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Y (voxels)&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;Root ID&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Fetching segmentation cutout...
Bounding box (nm):
  X: [329200. 333200.]
  Y: [91376. 95376.]
  Z: [112712. 112912.]

Cutout info:
  Shape: (124, 124, 4)
  Resolution: [32 32 42] nm/voxel
  Offset: [329216  91392 112728] nm

Found 311 unique segments in this volume
Segment IDs: [576460752499537597 576460752502187549 576460752502203933
 576460752502220317 576460752502236445 576460752502254877
 576460752502268701 576460752502268957 576460752502275869
 576460752502276893]...
</pre></div>
</div>
<img alt="../_images/15f85832c88c32622adc9e30a10ccac2aea4069f2a1275aa6d132abce42f9454.png" src="../_images/15f85832c88c32622adc9e30a10ccac2aea4069f2a1275aa6d132abce42f9454.png" />
</div>
</div>
</section>
</section>
<section id="voxel-level-operations">
<h2>7. Voxel-Level Operations<a class="headerlink" href="#voxel-level-operations" title="Link to this heading">#</a></h2>
<p>Work with individual voxels that make up a neuron.</p>
<section id="getting-all-voxels-for-a-neuron">
<h3>Getting All Voxels for a Neuron<a class="headerlink" href="#getting-all-voxels-for-a-neuron" title="Link to this heading">#</a></h3>
<p>This retrieves all voxel coordinates that belong to a specific root ID within a specified region.</p>
<p><strong>⚠️ Important: CloudVolume Coverage and Resolution</strong></p>
<p>When working with voxel-level data, keep in mind:</p>
<ul class="simple">
<li><p><strong>Limited Spatial Coverage</strong>: CloudVolume contains only a subset (~360 x 344 x 257 µm) of the full CAVE dataset</p></li>
<li><p><strong>Resolution Mismatch</strong>: CloudVolume’s highest resolution (MIP 0) is 16x16x42 nm/voxel, which is 2x coarser than CAVE’s base resolution (8x8x42 nm/voxel)</p></li>
<li><p><strong>Coordinate Systems</strong>: CAVE uses nanometers, CloudVolume uses voxels at the current MIP level</p></li>
</ul>
<p><strong>Best Practices:</strong></p>
<ol class="arabic simple">
<li><p><strong>Always provide explicit bounds</strong> within CloudVolume coverage to avoid errors</p></li>
<li><p><strong>Use small regions</strong> (&lt; 10 µm) for voxel queries - large regions can be slow</p></li>
<li><p><strong>Test bounds first</strong> using <code class="docutils literal notranslate"><span class="pre">get_segmentation_cutout</span></code> before fetching voxels</p></li>
<li><p><strong>For full neurons</strong>: Use L2 skeletons (<code class="docutils literal notranslate"><span class="pre">get_l2_skeleton</span></code>) or meshes (<code class="docutils literal notranslate"><span class="pre">get_mesh</span></code>) instead of voxels</p></li>
<li><p><strong>Choose appropriate MIP</strong>: Use MIP 1 for faster queries when precise resolution isn’t critical</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get voxels for one of our example neurons</span>
<span class="n">target_id</span> <span class="o">=</span> <span class="n">example_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fetching voxels for root ID: </span><span class="si">{</span><span class="n">target_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Define a small region around a known location within CloudVolume coverage</span>
<span class="c1"># Using center_location from earlier (which we know is within bounds)</span>
<span class="n">bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="n">center_location</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2000</span><span class="p">,</span> <span class="n">center_location</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2000</span><span class="p">],</span>  <span class="c1"># 4 µm window in X</span>
    <span class="p">[</span><span class="n">center_location</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2000</span><span class="p">,</span> <span class="n">center_location</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2000</span><span class="p">],</span>  <span class="c1"># 4 µm window in Y</span>
    <span class="p">[</span><span class="n">center_location</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">500</span><span class="p">,</span> <span class="n">center_location</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">500</span><span class="p">]</span>     <span class="c1"># 1 µm window in Z</span>
<span class="p">])</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Bounds (in nm):&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  X: [</span><span class="si">{</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">.0f</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.0f</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Y: [</span><span class="si">{</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">.0f</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.0f</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Z: [</span><span class="si">{</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">.0f</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.0f</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>

<span class="c1"># Method 1: Get voxels without supervoxel mapping (faster)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- Getting voxels (without supervoxel mapping) ---&quot;</span><span class="p">)</span>
<span class="n">voxels</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">get_voxels</span><span class="p">(</span>
    <span class="n">target_id</span><span class="p">,</span>
    <span class="n">mip</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>  <span class="c1"># Lower resolution for speed</span>
    <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
    <span class="n">use_l2_chunks</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="c1"># Use cutout method</span>
    <span class="n">sv_map</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="c1"># Don&#39;t map to supervoxels</span>
    <span class="n">progress</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>

<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">voxels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">✓ Retrieved </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">voxels</span><span class="p">)</span><span class="si">:</span><span class="s2">,</span><span class="si">}</span><span class="s2"> voxels&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Voxel ranges:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    X: [</span><span class="si">{</span><span class="n">voxels</span><span class="p">[:,</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">voxels</span><span class="p">[:,</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Y: [</span><span class="si">{</span><span class="n">voxels</span><span class="p">[:,</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">voxels</span><span class="p">[:,</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Z: [</span><span class="si">{</span><span class="n">voxels</span><span class="p">[:,</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">voxels</span><span class="p">[:,</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
    
    <span class="c1"># Method 2: Get voxels WITH supervoxel mapping</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- Getting voxels (with supervoxel mapping) ---&quot;</span><span class="p">)</span>
    <span class="n">voxels_sv</span><span class="p">,</span> <span class="n">sv_ids</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">get_voxels</span><span class="p">(</span>
        <span class="n">target_id</span><span class="p">,</span>
        <span class="n">mip</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
        <span class="n">use_l2_chunks</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">sv_map</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>  <span class="c1"># Map each voxel to its supervoxel ID</span>
        <span class="n">progress</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">✓ Retrieved </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">voxels_sv</span><span class="p">)</span><span class="si">:</span><span class="s2">,</span><span class="si">}</span><span class="s2"> voxels&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Number of unique supervoxels: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sv_ids</span><span class="p">))</span><span class="si">:</span><span class="s2">,</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Sample supervoxel IDs: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sv_ids</span><span class="p">)[:</span><span class="mi">5</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">⚠️ No voxels found in this region&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  This neuron may not have coverage in CloudVolume at this location&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Fetching voxels for root ID: 576460752681552812

Bounds (in nm):
  X: [329200, 333200]
  Y: [91376, 95376]
  Z: [112312, 113312]

--- Getting voxels (without supervoxel mapping) ---

✓ Retrieved 22,377 voxels
  Voxel ranges:
    X: [10314, 10400]
    Y: [2856, 2957]
    Z: [2674, 2697]

--- Getting voxels (with supervoxel mapping) ---

✓ Retrieved 22,377 voxels
  Number of unique supervoxels: 457
  Sample supervoxel IDs: [74732225463411215 74732225463419220 74732225463419226 74732225463419260
 74732225463421800]
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="spatial-coordinate-correction">
<h2>8. Spatial Coordinate Correction<a class="headerlink" href="#spatial-coordinate-correction" title="Link to this heading">#</a></h2>
<p>Sometimes your coordinates might not exactly hit the neuron you expect. You can “snap” them to the nearest voxel with the correct ID.</p>
<section id="snapping-coordinates-to-segmentation">
<h3>Snapping Coordinates to Segmentation<a class="headerlink" href="#snapping-coordinates-to-segmentation" title="Link to this heading">#</a></h3>
<p>This is useful for:</p>
<ul class="simple">
<li><p>Correcting slightly misaligned annotations</p></li>
<li><p>Ensuring synapses are on the correct neuron</p></li>
<li><p>Quality control of coordinate data</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Demonstration of snap_to_id functionality</span>
<span class="c1"># Note: This function requires CloudVolume coverage at the target locations</span>

<span class="n">target_id</span> <span class="o">=</span> <span class="n">example_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Target neuron: </span><span class="si">{</span><span class="n">target_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Create test locations near a region we know has data</span>
<span class="c1"># Make larger offsets to simulate imprecise annotations</span>
<span class="n">test_locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="n">center_location</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">500</span><span class="p">,</span> <span class="o">-</span><span class="mi">500</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span>
    <span class="n">center_location</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">500</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span>
    <span class="n">center_location</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">500</span><span class="p">,</span> <span class="o">-</span><span class="mi">500</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Test locations (with larger offsets to show snapping):&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">loc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">test_locs</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Location </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Check what segments these locations currently hit</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Checking current segmentation:&quot;</span><span class="p">)</span>
<span class="n">current_segments</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">locs_to_segments</span><span class="p">(</span><span class="n">test_locs</span><span class="p">,</span> <span class="n">coordinates</span><span class="o">=</span><span class="s2">&quot;nm&quot;</span><span class="p">)</span>

<span class="c1"># Find which segment is at the center location (our target)</span>
<span class="n">target_segment</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">locs_to_segments</span><span class="p">([</span><span class="n">center_location</span><span class="p">],</span> <span class="n">coordinates</span><span class="o">=</span><span class="s2">&quot;nm&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Target segment at center: </span><span class="si">{</span><span class="n">target_segment</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Show what we got at test locations</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">current_segments</span><span class="p">):</span>
    <span class="n">match</span> <span class="o">=</span> <span class="s2">&quot;✓&quot;</span> <span class="k">if</span> <span class="n">seg</span> <span class="o">==</span> <span class="n">target_segment</span> <span class="k">else</span> <span class="s2">&quot;✗&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Location </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">: segment </span><span class="si">{</span><span class="n">seg</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">match</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Try to snap to the target segment</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Attempting to snap all locations to segment: </span><span class="si">{</span><span class="n">target_segment</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">snapped_locs</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">snap_to_id</span><span class="p">(</span>
    <span class="n">test_locs</span><span class="p">,</span>
    <span class="nb">id</span><span class="o">=</span><span class="n">target_segment</span><span class="p">,</span>
    <span class="n">search_radius</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>  <span class="c1"># 500nm search radius</span>
    <span class="n">coordinates</span><span class="o">=</span><span class="s2">&quot;nm&quot;</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>

<span class="c1"># Verify</span>
<span class="n">snapped_segments</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">locs_to_segments</span><span class="p">(</span><span class="n">snapped_locs</span><span class="p">,</span> <span class="n">coordinates</span><span class="o">=</span><span class="s2">&quot;nm&quot;</span><span class="p">)</span>
<span class="n">matches</span> <span class="o">=</span> <span class="n">snapped_segments</span> <span class="o">==</span> <span class="n">target_segment</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">✓ After snapping: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">snapped_locs</span><span class="p">)</span><span class="si">}</span><span class="s2"> on target segment&quot;</span><span class="p">)</span>

<span class="c1"># Calculate movement</span>
<span class="n">movement</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">snapped_locs</span> <span class="o">-</span> <span class="n">test_locs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">successful</span> <span class="o">=</span> <span class="n">movement</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">successful</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Movement statistics:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Successfully snapped: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">successful</span><span class="p">)</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">movement</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Mean movement: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">movement</span><span class="p">[</span><span class="n">successful</span><span class="p">])</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> nm&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Max movement: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">movement</span><span class="p">)</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> nm&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Min movement: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">movement</span><span class="p">[</span><span class="n">successful</span><span class="p">])</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> nm&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">No locations needed snapping (all already correct)&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">💡 snap_to_id is useful for:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  - Correcting manually annotated synapse locations&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  - Fixing coordinates from image registration&quot;</span><span class="p">)</span>  
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  - Quality control of spatial annotations&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Target neuron: 576460752681552812

Test locations (with larger offsets to show snapping):
  Location 1: [330700.  92876. 112812.]
  Location 2: [330700.  93876. 112812.]
  Location 3: [331700.  92876. 112812.]

Checking current segmentation:
</pre></div>
</div>
<script type="application/vnd.jupyter.widget-view+json">{"model_id": "858272bc30e84629a45aa7ff7afb318c", "version_major": 2, "version_minor": 0}</script><script type="application/vnd.jupyter.widget-view+json">{"model_id": "1be8895792bc4d39b61716cadef65315", "version_major": 2, "version_minor": 0}</script><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Target segment at center: 576460752681552812
  Location 1: segment 576460752681552812 ✓
  Location 2: segment 576460752718331166 ✗
  Location 3: segment 576460752551830489 ✗

Attempting to snap all locations to segment: 576460752681552812
</pre></div>
</div>
<script type="application/vnd.jupyter.widget-view+json">{"model_id": "a4f9ab6ef7654b26973df1b1dc215a4c", "version_major": 2, "version_minor": 0}</script><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2 of 3 locations needed to be snapped.
Of these 0 locations could not be snapped - consider
increasing `search_radius`.
</pre></div>
</div>
<script type="application/vnd.jupyter.widget-view+json">{"model_id": "9b7c1f27c8a947d9badadca2ecfb89e2", "version_major": 2, "version_minor": 0}</script><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>✓ After snapping: 3/3 on target segment

Movement statistics:
  Successfully snapped: 2/3
  Mean movement: 233.14 nm
  Max movement: 382.08 nm
  Min movement: 84.19 nm

💡 snap_to_id is useful for:
  - Correcting manually annotated synapse locations
  - Fixing coordinates from image registration
  - Quality control of spatial annotations
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="temporal-analysis-edit-history">
<h2>9. Temporal Analysis: Edit History<a class="headerlink" href="#temporal-analysis-edit-history" title="Link to this heading">#</a></h2>
<p>CAVE segmentation is versioned - you can see how neurons have changed over time.</p>
<section id="getting-the-lineage-graph">
<h3>Getting the Lineage Graph<a class="headerlink" href="#getting-the-lineage-graph" title="Link to this heading">#</a></h3>
<p>The lineage graph shows all the edits (merges/splits) that led to the current version of a neuron.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get lineage graph for a neuron</span>
<span class="n">target_id</span> <span class="o">=</span> <span class="n">example_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Getting edit history for root ID: </span><span class="si">{</span><span class="n">target_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">get_lineage_graph</span><span class="p">(</span><span class="n">target_id</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Lineage graph statistics:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Number of versions: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Number of operations: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># Show the most recent versions</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Most recent versions (node IDs):&quot;</span><span class="p">)</span>
    <span class="n">recent_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())[</span><span class="o">-</span><span class="mi">5</span><span class="p">:]</span>  <span class="c1"># Last 5 nodes</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">recent_nodes</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;operation_id&#39;</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Operation: </span><span class="si">{</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;operation_id&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># Visualize the lineage graph</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">networkx</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nx</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> 
            <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;lightblue&#39;</span><span class="p">,</span> 
            <span class="n">node_size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
            <span class="n">with_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
            <span class="n">arrows</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">edge_color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Lineage Graph for Root </span><span class="si">{</span><span class="n">target_id</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span> <span class="n">fontweight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    
<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Note: Lineage graph requires proofreading history: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Getting edit history for root ID: 576460752681552812

Lineage graph statistics:
  Number of versions: 134
  Number of operations: 133

Most recent versions (node IDs):
  576460752759576858
  576460752678850552
  576460752681107663
    Operation: 126
  576460752726458923
  576460752764825007
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>/var/folders/y6/xn2dyw2s14b79mrpmzrhykhc0000gn/T/ipykernel_46047/230392531.py:32: UserWarning: This figure includes Axes that are not compatible with tight_layout, so results might be incorrect.
  plt.tight_layout()
</pre></div>
</div>
<img alt="../_images/4ed7dea92e3795cc640ce68d2985c23fd71640a7593fdbad875cca70b8525134.png" src="../_images/4ed7dea92e3795cc640ce68d2985c23fd71640a7593fdbad875cca70b8525134.png" />
</div>
</div>
</section>
<section id="finding-common-time-points">
<h3>Finding Common Time Points<a class="headerlink" href="#finding-common-time-points" title="Link to this heading">#</a></h3>
<p>If you’re analyzing multiple neurons, you might want to find a time when they all existed in a particular state.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Find a time when multiple neurons co-existed</span>
<span class="n">test_ids</span> <span class="o">=</span> <span class="n">example_ids</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Finding common time for </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">test_ids</span><span class="p">)</span><span class="si">}</span><span class="s2"> neurons...&quot;</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">common_time</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">find_common_time</span><span class="p">(</span><span class="n">test_ids</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Common time found: </span><span class="si">{</span><span class="n">common_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Date: </span><span class="si">{</span><span class="n">common_time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Time: </span><span class="si">{</span><span class="n">common_time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%H:%M:%S&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># You can use this timestamp to query historical states</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">You can now query the state of these neurons at this time:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  cp.locs_to_segments(locations, timestamp=</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">common_time</span><span class="o">.</span><span class="n">timestamp</span><span class="p">())</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
    
<span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">These neurons never co-existed: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Note: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Finding common time for 3 neurons...

Common time found: 2025-09-01 15:02:36.196459+00:00
  Date: 2025-09-01
  Time: 15:02:36

You can now query the state of these neurons at this time:
  cp.locs_to_segments(locations, timestamp=1756738956)
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="practical-workflows">
<h2>10. Practical Workflows<a class="headerlink" href="#practical-workflows" title="Link to this heading">#</a></h2>
<p>Let’s combine these tools in some practical workflows.</p>
<section id="workflow-1-validating-and-updating-a-list-of-neurons">
<h3>Workflow 1: Validating and Updating a List of Neurons<a class="headerlink" href="#workflow-1-validating-and-updating-a-list-of-neurons" title="Link to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Scenario: You have a list of neurons from an old analysis</span>
<span class="n">old_neuron_list</span> <span class="o">=</span> <span class="n">example_ids</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">old_neuron_list</span><span class="p">)</span><span class="si">}</span><span class="s2"> neurons from previous analysis&quot;</span><span class="p">)</span>

<span class="c1"># Step 1: Check validity</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">1. Checking if IDs are valid...&quot;</span><span class="p">)</span>
<span class="n">is_valid</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">is_valid_root</span><span class="p">(</span><span class="n">old_neuron_list</span><span class="p">)</span>
<span class="n">valid_ids</span> <span class="o">=</span> <span class="n">old_neuron_list</span><span class="p">[</span><span class="n">is_valid</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   ✓ </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">is_valid</span><span class="p">)</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">old_neuron_list</span><span class="p">)</span><span class="si">}</span><span class="s2"> are valid root IDs&quot;</span><span class="p">)</span>

<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_ids</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">old_neuron_list</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   ✗ </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">old_neuron_list</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="n">valid_ids</span><span class="p">)</span><span class="si">}</span><span class="s2"> invalid IDs removed&quot;</span><span class="p">)</span>

<span class="c1"># Step 2: Check if up-to-date</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">2. Checking if IDs are current...&quot;</span><span class="p">)</span>
<span class="n">is_latest</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">is_latest_roots</span><span class="p">(</span><span class="n">valid_ids</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   ✓ </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">is_latest</span><span class="p">)</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">valid_ids</span><span class="p">)</span><span class="si">}</span><span class="s2"> are up-to-date&quot;</span><span class="p">)</span>

<span class="c1"># Step 3: Update outdated IDs</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">3. Updating outdated IDs...&quot;</span><span class="p">)</span>
<span class="n">update_result</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">update_ids</span><span class="p">(</span><span class="n">valid_ids</span><span class="p">,</span> <span class="n">progress</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">updated_ids</span> <span class="o">=</span> <span class="n">update_result</span><span class="p">[</span><span class="s1">&#39;new_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

<span class="c1"># Step 4: Get supervoxels for stable tracking</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">4. Getting supervoxels for stable tracking...&quot;</span><span class="p">)</span>
<span class="n">sv_dict</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">roots_to_supervoxels</span><span class="p">(</span><span class="n">updated_ids</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">progress</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># Just first 3 for demo</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   ✓ Stored </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">sv_dict</span><span class="p">)</span><span class="si">}</span><span class="s2"> neurons with their supervoxels&quot;</span><span class="p">)</span>

<span class="c1"># Step 5: Save results</span>
<span class="n">result_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
    <span class="s1">&#39;old_id&#39;</span><span class="p">:</span> <span class="n">update_result</span><span class="p">[</span><span class="s1">&#39;old_id&#39;</span><span class="p">],</span>
    <span class="s1">&#39;new_id&#39;</span><span class="p">:</span> <span class="n">update_result</span><span class="p">[</span><span class="s1">&#39;new_id&#39;</span><span class="p">],</span>
    <span class="s1">&#39;changed&#39;</span><span class="p">:</span> <span class="n">update_result</span><span class="p">[</span><span class="s1">&#39;changed&#39;</span><span class="p">],</span>
    <span class="s1">&#39;confidence&#39;</span><span class="p">:</span> <span class="n">update_result</span><span class="p">[</span><span class="s1">&#39;confidence&#39;</span><span class="p">]</span>
<span class="p">})</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">5. Final results:&quot;</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">result_df</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Summary: </span><span class="si">{</span><span class="n">result_df</span><span class="p">[</span><span class="s1">&#39;changed&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="si">}</span><span class="s2"> neurons were updated&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Working with 3 neurons from previous analysis

1. Checking if IDs are valid...
   ✓ 3/3 are valid root IDs

2. Checking if IDs are current...
   ✓ 3/3 are up-to-date

3. Updating outdated IDs...
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2025-10-04 16:13:09 - WARNING - Multiple supervoxel IDs found for 130 root IDs. Using first occurrence for each.
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>4. Getting supervoxels for stable tracking...
   ✓ Stored 3 neurons with their supervoxels

5. Final results:
</pre></div>
</div>
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>old_id</th>
      <th>new_id</th>
      <th>changed</th>
      <th>confidence</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>576460752681552812</td>
      <td>576460752681552812</td>
      <td>False</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>576460752773799604</td>
      <td>576460752773799604</td>
      <td>False</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>576460752656800770</td>
      <td>576460752656800770</td>
      <td>False</td>
      <td>1.0</td>
    </tr>
  </tbody>
</table>
</div></div><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Summary: 0 neurons were updated
</pre></div>
</div>
</div>
</div>
</section>
<section id="workflow-2-quality-control-for-synapse-annotations">
<h3>Workflow 2: Quality Control for Synapse Annotations<a class="headerlink" href="#workflow-2-quality-control-for-synapse-annotations" title="Link to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Scenario: You have synapse locations and want to verify they&#39;re on the right neurons</span>

<span class="c1"># Get the actual segment at center_location (which we know has coverage)</span>
<span class="n">target_neuron</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">locs_to_segments</span><span class="p">([</span><span class="n">center_location</span><span class="p">],</span> <span class="n">coordinates</span><span class="o">=</span><span class="s2">&quot;nm&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Target neuron at center location: </span><span class="si">{</span><span class="n">target_neuron</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Simulated synapse locations (in practice, these come from your data)</span>
<span class="n">synapse_locations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="n">center_location</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">300</span><span class="p">,</span> <span class="o">-</span><span class="mi">300</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span>
    <span class="n">center_location</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">300</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span>
    <span class="n">center_location</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">300</span><span class="p">,</span> <span class="o">-</span><span class="mi">300</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span>
    <span class="n">center_location</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">300</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span>
    <span class="n">center_location</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Quality control for </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">synapse_locations</span><span class="p">)</span><span class="si">}</span><span class="s2"> synapses on neuron </span><span class="si">{</span><span class="n">target_neuron</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Step 1: Check which neurons these locations currently hit</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">1. Checking current segmentation at synapse locations...&quot;</span><span class="p">)</span>
<span class="n">current_roots</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">locs_to_segments</span><span class="p">(</span><span class="n">synapse_locations</span><span class="p">,</span> <span class="n">coordinates</span><span class="o">=</span><span class="s2">&quot;nm&quot;</span><span class="p">)</span>

<span class="n">matches</span> <span class="o">=</span> <span class="n">current_roots</span> <span class="o">==</span> <span class="n">target_neuron</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">synapse_locations</span><span class="p">)</span><span class="si">}</span><span class="s2"> synapses on correct neuron&quot;</span><span class="p">)</span>

<span class="c1"># Step 2: Snap misaligned synapses</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">matches</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">2. Correcting misaligned synapses...&quot;</span><span class="p">)</span>
    <span class="n">corrected_locs</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">snap_to_id</span><span class="p">(</span>
        <span class="n">synapse_locations</span><span class="p">,</span>
        <span class="nb">id</span><span class="o">=</span><span class="n">target_neuron</span><span class="p">,</span>
        <span class="n">search_radius</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
        <span class="n">coordinates</span><span class="o">=</span><span class="s2">&quot;nm&quot;</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>
    
    <span class="c1"># Verify corrections</span>
    <span class="n">corrected_roots</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">locs_to_segments</span><span class="p">(</span><span class="n">corrected_locs</span><span class="p">,</span> <span class="n">coordinates</span><span class="o">=</span><span class="s2">&quot;nm&quot;</span><span class="p">)</span>
    <span class="n">corrected_matches</span> <span class="o">=</span> <span class="n">corrected_roots</span> <span class="o">==</span> <span class="n">target_neuron</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   ✓ </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">corrected_matches</span><span class="p">)</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">synapse_locations</span><span class="p">)</span><span class="si">}</span><span class="s2"> now on correct neuron&quot;</span><span class="p">)</span>
    
    <span class="c1"># Calculate movement - ensure proper float arrays</span>
    <span class="n">movement</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">corrected_locs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">synapse_locations</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span> 
        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
    <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">3. Movement statistics:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   Mean: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">movement</span><span class="p">)</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> nm&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   Max: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">movement</span><span class="p">)</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> nm&quot;</span><span class="p">)</span>
    
    <span class="c1"># Create results DataFrame</span>
    <span class="n">synapse_qc</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
        <span class="s1">&#39;synapse_id&#39;</span><span class="p">:</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">synapse_locations</span><span class="p">)),</span>
        <span class="s1">&#39;original_x&#39;</span><span class="p">:</span> <span class="n">synapse_locations</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="s1">&#39;original_y&#39;</span><span class="p">:</span> <span class="n">synapse_locations</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="s1">&#39;original_z&#39;</span><span class="p">:</span> <span class="n">synapse_locations</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span>
        <span class="s1">&#39;corrected_x&#39;</span><span class="p">:</span> <span class="n">corrected_locs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="s1">&#39;corrected_y&#39;</span><span class="p">:</span> <span class="n">corrected_locs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="s1">&#39;corrected_z&#39;</span><span class="p">:</span> <span class="n">corrected_locs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span>
        <span class="s1">&#39;movement_nm&#39;</span><span class="p">:</span> <span class="n">movement</span><span class="p">,</span>
        <span class="s1">&#39;original_match&#39;</span><span class="p">:</span> <span class="n">matches</span><span class="p">,</span>
        <span class="s1">&#39;corrected_match&#39;</span><span class="p">:</span> <span class="n">corrected_matches</span>
    <span class="p">})</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">4. QC results:&quot;</span><span class="p">)</span>
    <span class="n">display</span><span class="p">(</span><span class="n">synapse_qc</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">✓ All synapses already on correct neuron!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<script type="application/vnd.jupyter.widget-view+json">{"model_id": "7430b9e019a74939a8084eae54658163", "version_major": 2, "version_minor": 0}</script><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Target neuron at center location: 576460752681552812

Quality control for 5 synapses on neuron 576460752681552812

1. Checking current segmentation at synapse locations...
</pre></div>
</div>
<script type="application/vnd.jupyter.widget-view+json">{"model_id": "9aa8dcbf905247e39bb4415697527a18", "version_major": 2, "version_minor": 0}</script><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>   3/5 synapses on correct neuron

2. Correcting misaligned synapses...
</pre></div>
</div>
<script type="application/vnd.jupyter.widget-view+json">{"model_id": "0834b41b8860440eae0057d7f955f2d2", "version_major": 2, "version_minor": 0}</script><script type="application/vnd.jupyter.widget-view+json">{"model_id": "4e44b8ee4ec247d7bb92542cb7e4e0f4", "version_major": 2, "version_minor": 0}</script><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>   ✓ 5/5 now on correct neuron

3. Movement statistics:
   Mean: 37.95 nm
   Max: 129.63 nm

4. QC results:
</pre></div>
</div>
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>synapse_id</th>
      <th>original_x</th>
      <th>original_y</th>
      <th>original_z</th>
      <th>corrected_x</th>
      <th>corrected_y</th>
      <th>corrected_z</th>
      <th>movement_nm</th>
      <th>original_match</th>
      <th>corrected_match</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>330900.0</td>
      <td>93076.0</td>
      <td>112812.0</td>
      <td>330912.0</td>
      <td>93104.0</td>
      <td>112938.0</td>
      <td>129.630243</td>
      <td>False</td>
      <td>True</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>330900.0</td>
      <td>93676.0</td>
      <td>112812.0</td>
      <td>330896.0</td>
      <td>93616.0</td>
      <td>112812.0</td>
      <td>60.133186</td>
      <td>False</td>
      <td>True</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>331500.0</td>
      <td>93076.0</td>
      <td>112812.0</td>
      <td>331500.0</td>
      <td>93076.0</td>
      <td>112812.0</td>
      <td>0.000000</td>
      <td>True</td>
      <td>True</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3</td>
      <td>331500.0</td>
      <td>93676.0</td>
      <td>112812.0</td>
      <td>331500.0</td>
      <td>93676.0</td>
      <td>112812.0</td>
      <td>0.000000</td>
      <td>True</td>
      <td>True</td>
    </tr>
    <tr>
      <th>4</th>
      <td>4</td>
      <td>331200.0</td>
      <td>93376.0</td>
      <td>112812.0</td>
      <td>331200.0</td>
      <td>93376.0</td>
      <td>112812.0</td>
      <td>0.000000</td>
      <td>True</td>
      <td>True</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
</section>
<section id="workflow-3-analyzing-segmentation-in-a-region">
<h3>Workflow 3: Analyzing Segmentation in a Region<a class="headerlink" href="#workflow-3-analyzing-segmentation-in-a-region" title="Link to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Scenario: Analyze all neurons in a specific brain region</span>
<span class="n">region_bbox</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="n">center_location</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2000</span><span class="p">,</span> <span class="n">center_location</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2000</span><span class="p">],</span>
    <span class="p">[</span><span class="n">center_location</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2000</span><span class="p">,</span> <span class="n">center_location</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2000</span><span class="p">],</span>
    <span class="p">[</span><span class="n">center_location</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">100</span><span class="p">,</span> <span class="n">center_location</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">100</span><span class="p">]</span>
<span class="p">])</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Analyzing segmentation in region:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  X: </span><span class="si">{</span><span class="n">region_bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Y: </span><span class="si">{</span><span class="n">region_bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Z: </span><span class="si">{</span><span class="n">region_bbox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Step 1: Get segmentation cutout</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">1. Fetching segmentation cutout...&quot;</span><span class="p">)</span>
<span class="n">cutout</span><span class="p">,</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">get_segmentation_cutout</span><span class="p">(</span>
    <span class="n">region_bbox</span><span class="p">,</span>
    <span class="n">root_ids</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">mip</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">coordinates</span><span class="o">=</span><span class="s2">&quot;nm&quot;</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   ✓ Cutout shape: </span><span class="si">{</span><span class="n">cutout</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Step 2: Find all neurons in this region</span>
<span class="n">unique_roots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cutout</span><span class="p">)</span>
<span class="n">unique_roots</span> <span class="o">=</span> <span class="n">unique_roots</span><span class="p">[</span><span class="n">unique_roots</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">2. Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_roots</span><span class="p">)</span><span class="si">}</span><span class="s2"> neurons in region&quot;</span><span class="p">)</span>

<span class="c1"># Step 3: Get annotations for these neurons</span>
<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_roots</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_roots</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">500</span><span class="p">:</span>  <span class="c1"># Limit to reasonable number</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">3. Fetching neuron annotations...&quot;</span><span class="p">)</span>
    <span class="n">region_annotations</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">get_annotations</span><span class="p">(</span><span class="n">unique_roots</span><span class="p">)</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;root_id&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="c1"># annotations may not be available for all neurons</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   ✓ Retrieved annotations for </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">region_annotations</span><span class="p">)</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_roots</span><span class="p">)</span><span class="si">}</span><span class="s2"> neurons&quot;</span><span class="p">)</span>
    <span class="c1"># fill in missing annotations</span>
    <span class="n">region_annotations</span> <span class="o">=</span> <span class="n">region_annotations</span><span class="p">[[</span><span class="s1">&#39;root_id&#39;</span><span class="p">,</span> <span class="s1">&#39;cell_class&#39;</span><span class="p">,</span> <span class="s1">&#39;cell_type&#39;</span><span class="p">,</span> <span class="s1">&#39;side&#39;</span><span class="p">]]</span>
    <span class="n">region_annotations</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="s1">&#39;Unknown&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># convert root_id to int for consistency</span>
    <span class="n">region_annotations</span><span class="p">[</span><span class="s1">&#39;root_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">region_annotations</span><span class="p">[</span><span class="s1">&#39;root_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>

    <span class="c1"># add neurons without annotations</span>
    <span class="n">missing_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">unique_roots</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">region_annotations</span><span class="p">[</span><span class="s1">&#39;root_id&#39;</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">missing_ids</span><span class="p">:</span>
        <span class="n">missing_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;root_id&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">missing_ids</span><span class="p">),</span> <span class="s1">&#39;cell_class&#39;</span><span class="p">:</span> <span class="s1">&#39;Unknown&#39;</span><span class="p">,</span> <span class="s1">&#39;cell_type&#39;</span><span class="p">:</span> <span class="s1">&#39;Unknown&#39;</span><span class="p">,</span> <span class="s1">&#39;side&#39;</span><span class="p">:</span> <span class="s1">&#39;Unknown&#39;</span><span class="p">})</span>
        <span class="n">region_annotations</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">region_annotations</span><span class="p">,</span> <span class="n">missing_df</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   ✗ </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">missing_ids</span><span class="p">)</span><span class="si">}</span><span class="s2"> neurons without annotations added as &#39;Unknown&#39;&quot;</span><span class="p">)</span>

    <span class="c1"># Analyze cell classes</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">4. Cell class distribution:&quot;</span><span class="p">)</span>
    <span class="n">cell_class_counts</span> <span class="o">=</span> <span class="n">region_annotations</span><span class="p">[</span><span class="s1">&#39;cell_class&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">cell_class_counts</span><span class="p">)</span>
    
    <span class="c1"># Visualize</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="n">cell_class_counts</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;steelblue&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Cell Classes in Region&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">fontweight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Cell Class&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Count&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="mi">45</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    
    <span class="c1"># Calculate volume occupied by each neuron</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">5. Volume analysis:&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">root_id</span> <span class="ow">in</span> <span class="n">unique_roots</span><span class="p">[:</span><span class="mi">5</span><span class="p">]:</span>  <span class="c1"># Just first 5</span>
        <span class="n">voxel_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cutout</span> <span class="o">==</span> <span class="n">root_id</span><span class="p">)</span>
        <span class="n">volume_nm3</span> <span class="o">=</span> <span class="n">voxel_count</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">resolution</span><span class="p">)</span>
        <span class="n">volume_um3</span> <span class="o">=</span> <span class="n">volume_nm3</span> <span class="o">/</span> <span class="mf">1e9</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   Root </span><span class="si">{</span><span class="n">root_id</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">voxel_count</span><span class="si">}</span><span class="s2"> voxels = </span><span class="si">{</span><span class="n">volume_um3</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> µm³&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Note: Too many neurons (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_roots</span><span class="p">)</span><span class="si">}</span><span class="s2">) for detailed analysis&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Analyzing segmentation in region:
  X: [329200. 333200.]
  Y: [91376. 95376.]
  Z: [112712. 112912.]

1. Fetching segmentation cutout...
   ✓ Cutout shape: (124, 124, 4)

2. Found 311 neurons in region

3. Fetching neuron annotations...
   ✓ Retrieved annotations for 15/311 neurons
   ✗ 296 neurons without annotations added as &#39;Unknown&#39;

4. Cell class distribution:
cell_class
Unknown                        310
olfactory_projection_neuron      1
Name: count, dtype: int64
</pre></div>
</div>
<img alt="../_images/5901dbbbac0ca621ab82a90827c8d8be113a8620f4cde2a71a16c7394783c4f9.png" src="../_images/5901dbbbac0ca621ab82a90827c8d8be113a8620f4cde2a71a16c7394783c4f9.png" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>5. Volume analysis:
   Root 576460752499537597: 38 voxels = 0.00 µm³
   Root 576460752502187549: 36 voxels = 0.00 µm³
   Root 576460752502203933: 378 voxels = 0.02 µm³
   Root 576460752502220317: 55 voxels = 0.00 µm³
   Root 576460752502236445: 423 voxels = 0.02 µm³
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="performance-tips-and-best-practices">
<h2>11. Performance Tips and Best Practices<a class="headerlink" href="#performance-tips-and-best-practices" title="Link to this heading">#</a></h2>
<section id="tip-1-cache-supervoxels-for-faster-updates">
<h3>Tip 1: Cache Supervoxels for Faster Updates<a class="headerlink" href="#tip-1-cache-supervoxels-for-faster-updates" title="Link to this heading">#</a></h3>
<p>Supervoxels never change, so caching them enables instant ID updates.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">time</span>

<span class="n">neurons_to_track</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">NeuronCriteria</span><span class="p">(</span><span class="n">cell_class</span><span class="o">=</span><span class="s1">&#39;olfactory_projection_neuron&#39;</span><span class="p">,</span> <span class="n">proofread</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">get_roots</span><span class="p">()[:</span><span class="mi">20</span><span class="p">]</span>

<span class="c1"># Slow: Update without supervoxels</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">result_slow</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">update_ids</span><span class="p">(</span><span class="n">neurons_to_track</span><span class="p">,</span> <span class="n">use_annotations</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">progress</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">time_slow</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Update without supervoxels: </span><span class="si">{</span><span class="n">time_slow</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>

<span class="c1"># Fast: Get and cache supervoxels once</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Caching supervoxels...&quot;</span><span class="p">)</span>
<span class="n">sv_cache</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">roots_to_supervoxels</span><span class="p">(</span><span class="n">neurons_to_track</span><span class="p">,</span> <span class="n">progress</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="c1"># Now use them for updates</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">supervoxels_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">sv_cache</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">rid</span><span class="p">)][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">rid</span> <span class="ow">in</span> <span class="n">neurons_to_track</span><span class="p">]</span>  <span class="c1"># Use first supervoxel</span>
<span class="n">result_fast</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">update_ids</span><span class="p">(</span><span class="n">neurons_to_track</span><span class="p">,</span> <span class="n">supervoxels</span><span class="o">=</span><span class="n">supervoxels_list</span><span class="p">,</span> <span class="n">progress</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">time_fast</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Update with supervoxels: </span><span class="si">{</span><span class="n">time_fast</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Speedup: </span><span class="si">{</span><span class="n">time_slow</span><span class="o">/</span><span class="n">time_fast</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">x faster with supervoxels!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Update without supervoxels: 0.18s

Caching supervoxels...
Update with supervoxels: 0.18s

Speedup: 1.0x faster with supervoxels!
</pre></div>
</div>
</div>
</div>
</section>
<section id="tip-2-use-appropriate-mip-levels">
<h3>Tip 2: Use Appropriate MIP Levels<a class="headerlink" href="#tip-2-use-appropriate-mip-levels" title="Link to this heading">#</a></h3>
<p>Higher MIP = lower resolution = faster queries.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># For different use cases, choose appropriate resolution:</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Recommended MIP levels:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  mip=0 (highest res): Precise synapse locations, detailed tracing&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  mip=1 (lowest res): General morphology, large structures&quot;</span><span class="p">)</span>

<span class="c1"># Example: Compare query times</span>
<span class="n">test_bbox</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="n">center_location</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2000</span><span class="p">,</span> <span class="n">center_location</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2000</span><span class="p">],</span>
    <span class="p">[</span><span class="n">center_location</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2000</span><span class="p">,</span> <span class="n">center_location</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2000</span><span class="p">],</span>
    <span class="p">[</span><span class="n">center_location</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">100</span><span class="p">,</span> <span class="n">center_location</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">100</span><span class="p">]</span>
<span class="p">])</span>

<span class="k">for</span> <span class="n">mip</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">cutout</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">get_segmentation_cutout</span><span class="p">(</span><span class="n">test_bbox</span><span class="p">,</span> <span class="n">mip</span><span class="o">=</span><span class="n">mip</span><span class="p">,</span> <span class="n">coordinates</span><span class="o">=</span><span class="s2">&quot;nm&quot;</span><span class="p">)</span>
    <span class="n">elapsed</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">mip=</span><span class="si">{</span><span class="n">mip</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">cutout</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> in </span><span class="si">{</span><span class="n">elapsed</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Recommended MIP levels:
  mip=0 (highest res): Precise synapse locations, detailed tracing
  mip=1 (lowest res): General morphology, large structures

mip=0: (250, 250, 4) in 2.01s

mip=1: (124, 124, 4) in 1.16s
</pre></div>
</div>
</div>
</div>
</section>
<section id="tip-3-batch-operations">
<h3>Tip 3: Batch Operations<a class="headerlink" href="#tip-3-batch-operations" title="Link to this heading">#</a></h3>
<p>Always process multiple coordinates/IDs in a single call.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Generate test data</span>
<span class="n">n_locations</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">test_locations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span>
    <span class="n">low</span><span class="o">=</span><span class="p">[</span><span class="n">center_location</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">5000</span><span class="p">,</span> <span class="n">center_location</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">5000</span><span class="p">,</span> <span class="n">center_location</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">500</span><span class="p">],</span>
    <span class="n">high</span><span class="o">=</span><span class="p">[</span><span class="n">center_location</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">5000</span><span class="p">,</span> <span class="n">center_location</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">5000</span><span class="p">,</span> <span class="n">center_location</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">500</span><span class="p">],</span>
    <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">n_locations</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">)</span>

<span class="c1"># Bad: Loop over locations</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">results_slow</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">test_locations</span><span class="p">[:</span><span class="mi">10</span><span class="p">]:</span>  <span class="c1"># Just 10 for demo</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">locs_to_segments</span><span class="p">([</span><span class="n">loc</span><span class="p">],</span> <span class="n">coordinates</span><span class="o">=</span><span class="s2">&quot;nm&quot;</span><span class="p">,</span> <span class="n">progress</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">results_slow</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">time_slow</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loop approach (10 locations): </span><span class="si">{</span><span class="n">time_slow</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>

<span class="c1"># Good: Batch processing</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">results_fast</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">locs_to_segments</span><span class="p">(</span><span class="n">test_locations</span><span class="p">[:</span><span class="mi">10</span><span class="p">],</span> <span class="n">coordinates</span><span class="o">=</span><span class="s2">&quot;nm&quot;</span><span class="p">,</span> <span class="n">progress</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">time_fast</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Batch approach (10 locations): </span><span class="si">{</span><span class="n">time_fast</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Speedup: </span><span class="si">{</span><span class="n">time_slow</span><span class="o">/</span><span class="n">time_fast</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">x faster with batching!&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">💡 Always use batch operations for multiple queries!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Loop approach (10 locations): 10.00s
Batch approach (10 locations): 9.71s

Speedup: 1.0x faster with batching!

💡 Always use batch operations for multiple queries!
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Link to this heading">#</a></h2>
<p>In this comprehensive deep dive, you learned:</p>
<p>✅ <strong>Hierarchical segmentation</strong> - Root IDs, L2 chunks, and supervoxels<br />
✅ <strong>Bidirectional conversions</strong> - Between roots and supervoxels<br />
✅ <strong>Location-based queries</strong> - Finding segments at specific coordinates<br />
✅ <strong>ID management</strong> - Validating and updating root IDs<br />
✅ <strong>Neuron mapping</strong> - Connecting spatial reconstructions to segmentation<br />
✅ <strong>Volume operations</strong> - Extracting segmentation cutouts<br />
✅ <strong>Voxel-level data</strong> - Working with individual voxels<br />
✅ <strong>Coordinate correction</strong> - Snapping locations to correct segments<br />
✅ <strong>Temporal analysis</strong> - Understanding edit history and lineage<br />
✅ <strong>Practical workflows</strong> - Real-world analysis pipelines<br />
✅ <strong>Performance optimization</strong> - Tips for efficient queries</p>
<section id="key-takeaways">
<h3>Key Takeaways<a class="headerlink" href="#key-takeaways" title="Link to this heading">#</a></h3>
<ol class="arabic simple">
<li><p><strong>Supervoxels are stable</strong> - Cache them for reliable tracking across edits</p></li>
<li><p><strong>Root IDs can change</strong> - Always validate and update old IDs</p></li>
<li><p><strong>Use appropriate resolution</strong> - Balance speed vs. precision with MIP levels</p></li>
<li><p><strong>Batch operations</strong> - Process multiple items together for better performance</p></li>
<li><p><strong>Location-based queries</strong> - Essential for connecting spatial data to segmentation</p></li>
<li><p><strong>Temporal awareness</strong> - Segmentation is versioned; use timestamps when needed</p></li>
<li><p><strong>Coordinate systems matter</strong> - CAVE uses nanometers, CloudVolume uses voxels</p></li>
<li><p><strong>CloudVolume has limits</strong> - Limited spatial coverage and resolution; use L2 skeletons/meshes for full neurons</p></li>
</ol>
</section>
<section id="common-use-cases">
<h3>Common Use Cases<a class="headerlink" href="#common-use-cases" title="Link to this heading">#</a></h3>
<p><strong>Synapse analysis</strong>: Use <code class="docutils literal notranslate"><span class="pre">locs_to_segments</span></code> + <code class="docutils literal notranslate"><span class="pre">snap_to_id</span></code> for quality control<br />
<strong>Neuron tracking</strong>: Use <code class="docutils literal notranslate"><span class="pre">roots_to_supervoxels</span></code> + <code class="docutils literal notranslate"><span class="pre">update_ids</span></code> for stable IDs<br />
<strong>Region analysis</strong>: Use <code class="docutils literal notranslate"><span class="pre">get_segmentation_cutout</span></code> for local connectivity<br />
<strong>Quality control</strong>: Use <code class="docutils literal notranslate"><span class="pre">neuron_to_segments</span></code> to validate reconstructions<br />
<strong>Historical analysis</strong>: Use <code class="docutils literal notranslate"><span class="pre">get_lineage_graph</span></code> + <code class="docutils literal notranslate"><span class="pre">find_common_time</span></code> for temporal studies<br />
<strong>Voxel operations</strong>: Use <code class="docutils literal notranslate"><span class="pre">get_voxels</span></code> with explicit bounds for small regions</p>
</section>
<section id="important-notes-on-voxel-operations">
<h3>Important Notes on Voxel Operations<a class="headerlink" href="#important-notes-on-voxel-operations" title="Link to this heading">#</a></h3>
<p>When working with voxel-level data (<code class="docutils literal notranslate"><span class="pre">get_voxels</span></code>, <code class="docutils literal notranslate"><span class="pre">get_segmentation_cutout</span></code>):</p>
<ul class="simple">
<li><p>CloudVolume covers only a subset of the full dataset (~360 µm cube)</p></li>
<li><p>Always specify explicit bounds to avoid coverage errors</p></li>
<li><p>Use small regions (&lt; 10 µm) for best performance</p></li>
<li><p>For complete neuron morphology, use <code class="docutils literal notranslate"><span class="pre">get_l2_skeleton</span></code> or <code class="docutils literal notranslate"><span class="pre">get_mesh</span></code> instead</p></li>
</ul>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./deep_dive"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="connectivity.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Deep Dive: Analyzing Connectivity</p>
      </div>
    </a>
    <a class="right-next"
       href="ngllink.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Deep Dive: From CRANTpy to Neuroglancer</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#authentication-setup">1. Authentication Setup</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#root-ids-and-supervoxels">2. Root IDs and Supervoxels</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#converting-root-ids-to-supervoxels">Converting Root IDs to Supervoxels</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#converting-supervoxels-to-root-ids">Converting Supervoxels to Root IDs</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#location-based-segmentation-queries">3. Location-Based Segmentation Queries</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#finding-supervoxels-at-locations">Finding Supervoxels at Locations</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#finding-root-ids-segments-at-locations">Finding Root IDs (Segments) at Locations</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#updating-and-validating-root-ids">4. Updating and Validating Root IDs</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#validating-root-ids">Validating Root IDs</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#updating-outdated-root-ids">Updating Outdated Root IDs</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#mapping-neurons-to-segmentation">5. Mapping Neurons to Segmentation</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#finding-overlapping-segments">Finding Overlapping Segments</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#segmentation-cutouts">6. Segmentation Cutouts</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#extracting-a-volume-of-segmentation">Extracting a Volume of Segmentation</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#voxel-level-operations">7. Voxel-Level Operations</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#getting-all-voxels-for-a-neuron">Getting All Voxels for a Neuron</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#spatial-coordinate-correction">8. Spatial Coordinate Correction</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#snapping-coordinates-to-segmentation">Snapping Coordinates to Segmentation</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#temporal-analysis-edit-history">9. Temporal Analysis: Edit History</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#getting-the-lineage-graph">Getting the Lineage Graph</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#finding-common-time-points">Finding Common Time Points</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#practical-workflows">10. Practical Workflows</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#workflow-1-validating-and-updating-a-list-of-neurons">Workflow 1: Validating and Updating a List of Neurons</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#workflow-2-quality-control-for-synapse-annotations">Workflow 2: Quality Control for Synapse Annotations</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#workflow-3-analyzing-segmentation-in-a-region">Workflow 3: Analyzing Segmentation in a Region</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#performance-tips-and-best-practices">11. Performance Tips and Best Practices</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tip-1-cache-supervoxels-for-faster-updates">Tip 1: Cache Supervoxels for Faster Updates</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tip-2-use-appropriate-mip-levels">Tip 2: Use Appropriate MIP Levels</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tip-3-batch-operations">Tip 3: Batch Operations</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#summary">Summary</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#key-takeaways">Key Takeaways</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#common-use-cases">Common Use Cases</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#important-notes-on-voxel-operations">Important Notes on Voxel Operations</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By CRANTb Community
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>